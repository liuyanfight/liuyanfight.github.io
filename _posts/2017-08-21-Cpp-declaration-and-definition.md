---
layout: post
title: 声明与定义
date: 2017-08-21
categories: C++ 
tags: C++ C++Primer
location: 杭州，滨江
finished: true
---

## 定义

为了支持分离式编译，C++ 将声明和定义区分开。

- 声明(declaration)使得名字为程序所知，一个文件若要使用别处定义的名字则必须包含其声明。
- 定义(definition)负责创建与名字关联的实体（**分配内存**）。

## 区别

- 变量声明规定了类型与名称，定义除此之外还申请了存储空间，也可赋初始值。
- 如果只需要声明变量，则加上`extern`声明，并且不要赋初值。 `extern int i;`
- 任何包含了显式初始化的声明即成为定义
- 变量能且只能被定义一次，却可以声明多次
- 基本类型变量的声明和定义（初始化）是同时产生的；而对于**对象**来说，声明和定义是**分开**的。



> 变量和对象不加extern永远是定义,类中的除外.
>
> 函数只有函数头是声明,有函数体是定义.
>
> 类永远只是声明.类成员函数的函数体是定义.

```c++
class C
{
	static int x;//这里的x是声明
	static const int a;;//这里的a是声明
	//非static变量在类定义对象时才分配内存.
	C();//这里的函数是声明
};

int C::x;//这个才是定义
const int C::a=11;//这个才是定义
```

## 静态全局变量(static)

当使用static修饰变量，就不能使用extern来修饰，即static和extern不可同时出现。

static修饰的全局变量的**声明与定义同时进行**，即当你在头文件中使用static声明了全局变量，同时它也被定义了。

static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其**值复制**给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并**不影响本身**在定义时的值。即在其他编译单元A使用它时，它所在的物理地址，和其他编译单元B使用它时，它所在的**物理地址不一样**，A和B对它所做的修改都不能传递给对方。

多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储。

注：一般定义static 全局变量时，都把它放在.cpp文件中而不是.h文件中，这样就不会给其他编译单元造成不必要的信息污染。

## **全局常量(const)**

const单独使用时，其特性与static一样（每个编译单元中地址都不一样，不过因为是常量，也不能修改，所以就没有多大关系）。

const与extern一起使用时，其特性与extern一样。

```c++
1. extern const char g_szBuffer[];      //写入 .h中  
2. const char g_szBuffer[] = "123456"; // 写入.cpp中
```

## Related

[声明和定义 (C++)](https://msdn.microsoft.com/zh-cn/library/0e5kx78b.aspx)

[到底如何区分声明和定义](http://bbs.csdn.net/topics/190026622)

[C++全局变量的声明和定义](http://blog.csdn.net/candyliuxj/article/details/7853938)